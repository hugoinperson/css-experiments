'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _isGetSetProp = require('is-get-set-prop');

var _isGetSetProp2 = _interopRequireDefault(_isGetSetProp);

var _isJsType = require('is-js-type');

var _isJsType2 = _interopRequireDefault(_isJsType);

var _isObjProp = require('is-obj-prop');

var _isObjProp2 = _interopRequireDefault(_isObjProp);

var _isProtoProp = require('is-proto-prop');

var _isProtoProp2 = _interopRequireDefault(_isProtoProp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Return type of value of left or right
 * @param {Object} o - left or right of node.object
 * @return {String} - type of o
 */
var getType = function getType(o) {
  var type = _typeof(o.value);

  if (o.regex) {
    return 'RegExp';
  }

  return type.charAt(0).toUpperCase() + type.slice(1);
};

/**
  * Returns type of binary expression result
  * @param {Object} o - node's object with a BinaryExpression type
  * @return {String} - type of value produced
  */
var binaryExpressionProduces = function binaryExpressionProduces(o) {
  var leftType = o.left.type === 'BinaryExpression' ? binaryExpressionProduces(o.left) : getType(o.left),
      rightType = o.right.type === 'BinaryExpression' ? binaryExpressionProduces(o.right) : getType(o.right);

  if (leftType === 'String' || rightType === 'String' || leftType === rightType && leftType === 'RegExp') {
    return 'String';
  }

  if (leftType === rightType) {
    return leftType;
  }

  return 'Unknown';
};

/**
 * Returns the property name and prototype to validate
 * @param {Object} node - node to examine
 * @return {Object} - methodName and proto
 */
var getMethodNameAndPrototype = function getMethodNameAndPrototype(node) {
  var methodName = void 0,
      prototype = void 0;

  if (node.object.type === 'NewExpression') {
    prototype = node.object.callee.name;
  } else if (node.object.type === 'Literal') {
    prototype = getType(node.object);
  } else if (node.object.type === 'BinaryExpression') {
    prototype = binaryExpressionProduces(node.object);
  } else if (node.object.type === 'Identifier' && node.property.name === 'prototype' && node.parent.property) {
    prototype = node.object.name;
    methodName = node.parent.property.name;
  } else if (node.property.type === 'Identifier' && node.object.type === 'Identifier') {
    prototype = node.object.name;
  } else {
    prototype = node.object.type.replace('Expression', '');
  }

  methodName = methodName || node.property.name || node.property.value;

  return { methodName: methodName, prototype: prototype };
};

module.exports = function (context) {
  return {
    MemberExpression: function MemberExpression(node) {
      /* eslint complexity: [2, 9] */
      var isArgToParent = node.parent.arguments && node.parent.arguments.indexOf(node) > -1;
      var type = isArgToParent ? node.type : node.parent.type;

      var _getMethodNameAndProt = getMethodNameAndPrototype(node);

      var methodName = _getMethodNameAndProt.methodName;
      var prototype = _getMethodNameAndProt.prototype;


      if (typeof methodName !== 'string' || typeof prototype !== 'string' || !(0, _isJsType2.default)(prototype)) {
        return;
      }

      var isExpression = type === 'ExpressionStatement' || type === 'MemberExpression';
      var unknownGetterSetterOrPrototypeExpressed = isExpression && !(0, _isGetSetProp2.default)(prototype, methodName) && !(0, _isProtoProp2.default)(prototype, methodName) && !(0, _isObjProp2.default)(prototype, methodName);

      var isFunctionCall = type === 'CallExpression';
      var getterSetterCalledAsFunction = isFunctionCall && (0, _isGetSetProp2.default)(prototype, methodName);
      var unknownPrototypeCalledAsFunction = isFunctionCall && !(0, _isProtoProp2.default)(prototype, methodName) && !(0, _isObjProp2.default)(prototype, methodName);

      if (unknownGetterSetterOrPrototypeExpressed || getterSetterCalledAsFunction || unknownPrototypeCalledAsFunction) {
        context.report(node, 'Avoid using extended native objects');
      }
    }
  };
};